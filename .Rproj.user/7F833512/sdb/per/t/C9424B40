{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Tidyeval Tutorial\"\nauthor: \"Methods Consultants of Ann Arbor\"\ndate: \"07/13/2017\"\noutput: \n  ioslides_presentation:\n    widescreen: true\n    smaller: true\n    logo: mc_logo_rectangle.png\n    css: mc_slides.css\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, error = TRUE)\n\nlibrary(tidyverse)\nlibrary(rlang)\nlibrary(knitr)\n\n```\n\n## Data\n\n```{r}\ndata(mtcars)\nhead(mtcars)\n```\n\n## Standard vs Non-Standard Evalulation\n\nStandard evaluation: R passes arguments by value. \n\nNon-standard evaluation (NSE): Catch-all term that means anything other than standard evaluation.\n\nDplyr NSE: Allows objects that do not exist in global environment as inputs. \n\n```{r}\ngroup_by(mtcars, cyl) %>%\n  head(n=3)\n```\n\nWith standard evaluation, cyl cannot be an input as it doesn't exist in global environment. \n\n## Non-Standard Evalulation Issues\n\nWhile NSE can be extremely convienient, it causes problems when using non-interactively. \n\n```{r}\noops <- function(var) {\n  mtcars %>%\n    group_by(var)\n}\n\noops(cyl)\n```\n\nThis is where tidyeval comes in.\n\n## Tidyeval\n\n- Tidyeval is a toolkit for the tidyverse\n\n- It was created to help get around the issues that NSE can cause \n\n- Elegantly functionize dplyr code (other tidyverse packages will have support soon)\n\n## Intro to BangBang\n\nWe'll start with a few interactive examples to help get an intuition for how these functions work\n\n```{r}\nmtcars %>%\n  select(2) %>%\n  head(n=3)\n```\n\n```{r}\nhp <- 2\n\nmtcars %>%\n  select(hp) %>%\n  head(n=3)\n```\n\n## Intro to BangBang\n\nThe `!!` operator, pronounced BangBang, tells dplyr to evaluate the object prior to using it. \n\n```{r}\nmtcars %>%\n  select(!!hp) %>%\n  head(n=3)\n```\n\n## Intro to BangBang\n\n`expr()` allows us to debug our tidyeval code, it lets us see what R is trying to evaluate. \n\n```{r}\nexpr(\n  mtcars %>%\n    select(hp) %>%\n    head(n=3)\n)\n```\n\n```{r}\nexpr(\n  mtcars %>%\n    select(!!hp) %>%\n    head(n=3)\n)\n```\n\n## Intro to quo and sym\n\n```{r}\nmtcars %>%\n  filter(gear == 4) %>%\n  head(n=3) %>%\n  kable()\n```\n\n## Intro to quo and sym\n\n```{r}\nx <- \"gear\"\n\nmtcars %>%\n  filter(x == 4) %>%\n  head(n=3) %>%\n  kable()\n\nexpr(\n  mtcars %>%\n    filter(x == 4) %>%\n    head(n=3) %>%\n    kable()\n)\n```\n\nFilter ignores that x has an assigned value, \"gear\". We would like x to be evaluated (replaced with \"gear\") prior to being used by filter.\n\n## Intro to quo and sym\n\n```{r}\nmtcars %>%\n  filter((!!x) == 4) %>%\n  head(n=3) %>%\n  kable()\n\nexpr(\n  mtcars %>%\n    filter((!!x) == 4) %>%\n    head(n=3) %>%\n    kable()\n)\n```\n\n`!!` tells dplyr to evaluate `x` a step before evaluating the whole expression\n\nHowever we don't want a string there, we want the object name to be a symbol. \n\n## Intro to quo and sym\n\n`sym()` converts string to symbol\n\n```{r}\nexpr(x)\nexpr(!!x)\nx <- sym(x)\nexpr(!!x)\n```\n\n## Intro to quo and sym\n\n```{r}\nx <- sym(\"gear\")\n\nmtcars %>%\n  filter((!!x) == 4) %>%\n  head(n=3) %>%\n  kable()\n```\n\n## Intro to quo and sym\n\nBe careful: `filter((!!x) == 4)` is different from `filter(!!x == 4)` \n\n```{r}\nexpr(\n  mtcars %>%\n    filter((!!x) == 4) %>%\n    head(n=3) %>%\n    kable()\n)\n\nexpr(\n  mtcars %>%\n    filter(!!x == 4) %>%\n    head(n=3) %>%\n    kable()\n)\n```\n\n## Intro to quo and sym\n\nIf we want our input to be unquoted, then we use `quo()`\n\n```{r}\nx <- gear\n```\n\nR tries to evaluate `gear` and save it into `x`. We know `gear` doesn't exist, and we don't want R to try to evaluate it globally. Just save the expression in `x`!\n\n```{r}\nx <- quo(gear)\nexpr(x)\nexpr(!!x)\n```\n\n## Intro to quo and sym\n\n```{r}\nx <- quo(gear)\n\nmtcars %>%\n  filter((!!x) == 4) %>%\n  head(n=3) %>%\n  kable()\n```\n\n\n## Definitions\n\n`!!`: tells R to evaluate the object prior to using it.\n\n`sym()`: takes string input and converts to symbol; since dplyr deprecated the underscore functions, it only takes unquoted inputs (symbols)\n\nquosure: a quosure is a quoted object that keeps track of its environment\n\n`quo()`: takes unquoted R code and returns a quosure ready to be evaluated\n\n`enquo()`: takes symbol referring to function argument, returns quosure of input to function\n\n## tl;dr\n\n***Coding interactively*** (useful while building function): use `sym()` or `quo()`\n\n***Inside function***: use `sym()` or `enquo()`\n\n## Difference between `quo()` and `enquo()`\n\nSay we're trying to group `mtcars` by `cyl`, and need to make a closure of `cyl`\n\nIf working interactively:\n\n  - use `quo(cyl)`\n\nIf making `function(df, var)`, where user inputs `var = cyl`:\n\n  - use `enquo(var)`\n  - `quo(var)` would make closure of `var`\n\n## Enquo and sym example\n\n```{r}\nmtcars %>% \n  select(cyl) %>% \n  head(n=3) %>%\n  kable()\n```\n\n## Enquo and sym example\n\n```{r}\n\nselect3 <- function(df, select_var) {\n\n  df %>% \n    select(!!select_var) %>% \n    head(n=3) %>%\n    kable()\n  \n}\n\nmtcars %>% \n  select3(cyl)\n\n```\n\nTries to evaluate `cyl` globablly, we need to use `enquo()` so that `cyl` can be used correctly by dplyr. \n\n## Enquo and sym example\n\n```{r}\nselect3 <- function(df, select_var) {\n\n  select_var <- enquo(select_var)\n  \n  df %>% \n    select(!!select_var) %>% \n    head(n=3) %>%\n    kable()\n\n}\n\nmtcars %>% \n  select3(cyl)\n```\n\n\n## Enquo and sym example\n\n```{r}\nselect3_string <- function(df, select_var) {\n  \n  select_var <- sym(select_var)\n  \n  df %>% \n    select(!!select_var) %>% \n    head(n=3) %>%\n    kable()\n\n}\n\nmtcars %>% \n  select3_string(\"cyl\")\n```\n\n## Expression instead of variable\n\n```{r}\nfilter3 <- function(expression) {\n  \n  expression <- enquo(expression)\n  \n  mtcars %>%\n    filter(!!expression) %>%\n    head(n=3) %>%\n    kable()\n\n}\n\nfilter3(vs == 0)\n```\n\n## Dynamic Naming\n\n```{r}\nname3 <- function(var) {\n  \n  var <- enquo(var)\n  \n  mtcars %>%\n    mutate(x = ((!!var) - mean(!!var))/sd(!!var)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n\nname3(mpg)\n```\n\n## Dynamic Naming\n\n```{r}\nname3 <- function(var) {\n  \n  var <- enquo(var)\n  \n  mtcars %>%\n    mutate(!!var = ((!!var) - mean(!!var))/sd(!!var)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n```\n\n`!!var = ((!!var) - mean(!!var))/sd(!!var)` is not valid R code, the \\``=`\\` operator can only have object names on the LHS. We need to use \\``:=`\\` operator to unquote on both RHS and LHS.\n\n## Definitions\n\n\\``:=`\\`: bundles expressions on both the LHS and RHS. \n\n`quo_name()`: converts quoted symbol to string\n\n## Dynamic Naming\n\n```{r}\nname3 <- function(var) {\n  \n  var <- enquo(var)\n  \n  mtcars %>%\n    mutate(!!var := ((!!var) - mean(!!var))/sd(!!var)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n\nname3(mpg)\n```\n\n## Dynamic Naming\n\n```{r}\nname3 <- function(var) {\n  \n  var <- enquo(var)\n  \n  name <- quo_name(var)\n  \n  mtcars %>%\n    mutate(!!name := ((!!var) - mean(!!var))/sd(!!var)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n\nname3(mpg)\n```\n\n## Dynamic Naming\n\n```{r}\nname3 <- function(var) {\n  \n  var <- enquo(var)\n  \n  name <- paste0(\"z_\", quo_name(var))\n  \n  mtcars %>%\n    mutate(!!name := ((!!var) - mean(!!var))/sd(!!var)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n\nname3(mpg)\n```\n\n## Definitions\n\n`syms()`: takes a list of strings and converts to list of symbols\n\n`quos()`: takes a list of expressions and returns list of quosures\n\n`!!!`: unquotes each element of list, each component is embedded as its own argument in surrounding call\n\n## Quos, syms, !!! example\n\n```{r}\n\ng <- c(\"gear\", \"cyl\")\n\nmultiple_group <- function(df, group_vars) {\n  \n  group_vars <- syms(group_vars)\n  \n  df %>%\n    group_by(!!!group_vars) %>%\n    summarise(mean(hp)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n\n```\n\n## Quos, syms, !!! example\n\n```{r}\n\nmultiple_group(mtcars, g)\nmultiple_group(mtcars, \"gear\")\n\n```\n\n## Quos, syms, !!! example\n\n```{r}\nmultiple_group <- function(df, ...) {\n  \n  val_var <- enquo(val_var)\n  groupings <- quos(...)\n  \n  df %>%\n    group_by(!!!groupings) %>%\n    summarise(mean(hp)) %>%\n    head(n=3) %>%\n    kable()\n  \n}\n```\n\n## Quos, syms, !!! example\n\n```{r}\nmultiple_group(mtcars, gear)\nmultiple_group(mtcars, gear, cyl)\n\n```\n\n## Quos example 2\n\n```{r}\n(example <- tibble(group=c(rep(\"A\",6), rep(\"B\",6)), val = c(1:5, NA, 7:11, 1000)))\n```\n\n## Quos example 2\n\n```{r}\ngrouped_mean <- function(df, ...) {\n  \n  args <- quos(...)\n\n  df %>%\n    group_by(group) %>%\n    summarise(value = mean(val, !!!args)) %>%\n    kable()\n  \n}\n```\n\n## Quos example 2\n\n```{r}\ngrouped_mean(example)\ngrouped_mean(example, na.rm = TRUE)\n```\n\n## Quos example 2\n\n```{r}\ngrouped_mean(example, trim = .2)\ngrouped_mean(example, na.rm = TRUE, trim = .2)\n```\n\n## Allow either string or expression\n\n```{r}\ngroup_either <- function(var) {\n  var <- as.character(substitute(var))\n  var <- sym(var)\n  \n  mtcars %>%\n    group_by(!!var) %>%\n    summarise(mean(hp))\n}\n```\n\n## Allow either string or expression\n\n```{r}\ngroup_either(cyl)\ngroup_either(\"cyl\")\n```\n\n## Final notes\n\nNeed to explicitly load rlang if you want to use `expr()`, `sym()`, or `syms()`. Other functions are already loaded into dplyr.\n\nBe careful when using `!!` without parentheses.",
    "created" : 1499972678903.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "695142669",
    "id" : "C9424B40",
    "lastKnownWriteTime" : 1499972684,
    "last_content_update" : 1499972684535,
    "path" : "~/Pedagogy/tidyeval/Slides/Slides.Rmd",
    "project_path" : "Slides/Slides.Rmd",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}